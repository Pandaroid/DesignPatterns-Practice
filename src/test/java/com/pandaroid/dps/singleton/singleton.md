# 1. 单例模式的应用场景

单例模式（Singleton Pattern）是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。

- 隐藏其所有构造方法：构造方法私有
- 提供一个全局访问点，入口
- 属于创建型模式

单例应用场景：

- ServletContext 单实例、多线程
- ServletConfig 配置只能一个
- ApplicationContext
- DBPool

# 2. 常见的单例模式写法

常见写法：

- 饿汉式单例
- 懒汉式单例
- 注册式单例
- ThreadLocal 单例

## 2.1 饿汉式单例

在单例类首次加载时就创建实例。

- 不管用不用，先吃饱再说

缺点：

- 浪费内存空间
  - 如果初始化了，却没有使用
  - 这样的单例数量越多，浪费越大
- 只适合小范围、大概率会使用此单例的情况下使用

## 2.2 懒汉式单例

被外部类调用时才创建实例。单例类加载时，并不初始化。

DCL 对 instance 进行了两次 null 判断，第一层判断主要是为了避免不必要的同步，第二层的判断则是为了在 null 的情况下创建实例。 

DCL 单例优点：

- 资源利用率高：不执行 getInstance 就不会被实例化
- 多线程下效率高：双重检查加锁（Double Check Lock）避免每次调用 getInstance 方法时都同步

DCL 单例缺点：

- 第一次初始化时比较慢，并行时后面的线程需要排队等待第一次初始化
- 有 bug ：DCL 失效问题
  - 主要是因为 JLS 规范，编译器为了提高效率而进行了指令重排，**只要认为单线程下没问题**，就可以进行乱序写入，以保证不让 CPU 指令流水线中断
  - 因此，**在多线程的情况下**，DCL 下 lazySimpleSingletonIns 可能得到一个不为 null 但构造不完全的对象，有序性无法保证

为了提高代码的执行效率，JVM 会将执行频率高的代码编译成机器码，而对于频率不高的代码则仍然采用解释执行。常见的编译优化方式有：

- 方法内联：免去参数、返回值传递过程

- 去虚拟化：接口的方法只有一个实现类，进行方法内联

- 冗余消除：运行时去掉无用代码

- 还有一些编译优化根据“逃逸分析”技术
  - 标量替换：User u = new User("zhang3", 18) 
    - String n = "zhang3" int age = 18 ，节省内存
  - 栈上分配：逃逸对象直接在栈上分配，快速，GC 及时
  - 锁消除：去掉不必要的锁同步

```java
lazyDCLSingletonIns = new LazyDCLSingleton();
```

上述代码运行到底发生了什么？

- memory = allocate(); 	                     // 1：分配对象的内存空间
- ctorInstance(memory);                      // 2：初始化对象

- lazyDCLSingletonIns = memory;      // 3：设置 lazyDCLSingletonIns 指向刚分配的内存地址

然后用户的代码会对 lazyDCLSingletonIns 进行初次访问，极小的概率会出现 DCL 失效 bug 。

上面的伪代码中 2 、3 步可能发生指令重排，变为 3 、2 ，导致用户初次访问时，获得一个不为 null 但是未初始化完全的对象。

解决方案：可以通过内部类单例或 volatile 保证有序性。

- 官方比较推荐内部类单例方案

  - 原理：一个类只有在被使用时才会初始化，而类初始化过程是非并行的，这些都由JLS能保证。

- volatile 关键字

  - Java 5 以后的版本，可以利用 volatile 关键字。

    Why ？

    在 Java 5 以前，volatile 原语不怎么强大，只能保证对象的可见性

    但在 Java 5 之后，volatile 语义加强了，被 volatile 修饰的对象，将禁止该对象上的读写指令重排序

    这样，就保证了线程 B 读对象时，已经初始化完全了

# 3. 保证线程安全的单例模式策略



# 4. 反射暴力攻击单例解决方案及原理分析



# 5. 序列化破坏单例的原理及解决方案

