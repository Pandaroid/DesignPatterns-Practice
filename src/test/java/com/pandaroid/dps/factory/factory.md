**简单工厂模式（Simple Factory Pattern）**是指由一个工厂对象决定创建出哪一种产品类的实例。

它属于**创建型模式**，但它不属于 GOF 的 23 种设计模式。

它将创建产品实例的过程进行封装，使得其复杂性和过程对外不可见。

有利于代码复用，增强易用性。



# 1. 简单工厂模式 Simple Factory

简单工厂模式，首先，我们要明确我们的产品。比如，我之前在互联网金融公司做架构，当时我们每天要发标，也就是发布用户可以购买的信托产品。

然后信托产品也是分种类的，我们当时做的都是集合信托，但是资金投向方式不同，需要展示给用户的信托信息也不同，如：基础设施类信托、房地产信托、工商企业类信托、证券投资类信托、银信合作类信托、消费金融类信托等。

简单工厂模式，所有创建产品的逻辑都在一个简单工厂类里，如果有一个产品的创建逻辑发生变化，则修改可能会影响其他产品，违背**开闭原则**、**单一职责原则**。

# 2. 工厂方法模式 Factory Method

工厂方法模式（Factory Method Pattern）是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。

属于 GOF 23 种设计模式之一，**创建型设计模式**。

解决问题：产品链增加，造成的工厂类职责过多。简单工厂每次增加产品，都会违背开闭原则，去进行创建产品方法的修改。

将创建一个产品的逻辑放到一个类里面，符合**单一职责原则**。每次增加一个产品，就增加一个工厂类，不用每次都去修改简单工厂的创建产品方法。

使用的时候，将选择权交给用户。遵循**单一职责原则**，只有一个可能引起类变化修改的原因。

把简单工厂的工厂类职责拆离，不同的工厂生产不同的产品。每一种产品都有相应的子工厂创建，发生修改变更只会影响自己，不会影响其他产品。方便代码的扩展维护，扩展时不用修改原来的代码，遵循开闭原则。

适用场景：

1. 创建对象需要大量重复的代码。
2. 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。
3. 一个类通过其子类来指定创建哪个对象。

优点：

1. 用户只需关心所需产品对应的工厂，无须关心创建细节。
2. 加入新产品符合开闭原则，提高了系统的可扩展性。

缺点：

1. 类的个数容易过多，增加了代码结构的复杂度。
2. 增加了系统的抽象性和理解难度。

# 3. 抽象工厂模式 Abstract Factory Pattern

抽象工厂模式（Abstract Factory Pattern）是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。

属于创建型设计模式。

工厂可能不存在，设计好了他的创建模板，工厂可能是后来才生成的。逻辑抽象好，写在最顶层，这样进一步提升了扩展性。

理解抽象工厂模式必须要理解产品族和产品等级结构的概念。

- 一个产品族可以理解为一个品牌，该品牌的产品族包括冰箱、洗衣机、空调等，一个品牌下面有多个产品，构成产品族，一个产品有多个产品等级结构（产品规格）
- 如果一个产品族（品牌）中的每个产品有多个产品等级结构，就适合使用抽象工厂模式

我们的信托标的为了提供更好的流动性和灵活性、以及进行运营活动，增加了活期标、可转让标、体验标，原来的标的都是定期的不可转让标旳。

- 我们可以把标的原来的类型（基础设施类信托、房地产信托、工商企业类信托等）看作产品族，而新的活期标、可转让标、活动标看作产品等级结构
- 活期标类比余额宝；可转让标类比可转让的银行定期存款；体验比类比余额宝体验金；定期标的类比银行定期

抽象工厂模式解决的问题：

- 产品族 + 产品等级结构，非常复杂
- 每一个产品的创建逻辑也是比较复杂的、存在差异化的，实际实施中，可能会频繁修改
- 扩展性非常强，对工厂抽象、对产品抽象，完全面向接口

再次理解：

- 一个工厂 Factory 生产的所有产品，理解为**产品族**，如：一个基础设施类信托标的工厂生产的体验标、活期标、可转让标、定期标产品，构成一个产品族
- 一类产品可被多个不同的工厂创建，多个工厂创建的一类产品构成该产品的**产品等级结构**，如：活期标的基础设施类、房地产类、工商企业类等信托标的

抽象工厂的问题：

- 不符合**开闭原则**，如果要增加一类产品（比如：接力标），则需要自上而下的修改，接口中增加 create 产品，实现类中都必须要增加相应产品的 create 实现方法

抽象工厂模式的适用场景：

- 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。
- 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。
- 提供一个产品类的库，所有产品以同样的接口出现，从而使客户端不依赖于具体实现。

工厂和产品的接口都已经定义好了，后面需要增加工厂或产品，则只需要增加具体的类即可。对于增加产品，工厂接口和实现类会增加对应的 create 方法，一定程度上违反**开闭原则**，但对于不同的 create 方法创建自己对应的产品来说，实际上不互相影响，所以这里我认为只是一定程度上的违反，但是得到了更大的灵活性和可维护性。

Spring 源码中的抽象工厂模式：

- AbstractBeanFactory

  - 子类：DefaultListableBeanFactory 
  - 子类：XmlBeanFactory
  - 子类：AbstractAutowireCapableBeanFactory

- 继承的父类 AbstractBeanFactory ，其中有 

  - ```java
    protected abstract BeanDefinition getBeanDefinition(String beanName) throws BeansException;
    ```

  - ```java
    protected abstract Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
          throws BeanCreationException;
    ```

抽象工厂在 Spring 中广泛应用。

优点：

- 具体产品在应用层代码隔离，无需关心创建细节
- 将一个系列的产品族统一到一起创建

缺点：

- 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。
- 增加了系统的抽象性和理解难度。使得代码层次结构更复杂。