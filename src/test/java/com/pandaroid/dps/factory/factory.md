**简单工厂模式（Simple Factory Pattern）**是指由一个工厂对象决定创建出哪一种产品类的实例。

它属于**创建型模式**，但它不属于 GOF 的 23 种设计模式。

它将创建产品实例的过程进行封装，使得其复杂性和过程对外不可见。

有利于代码复用，增强易用性。



# 1. 简单工厂模式 Simple Factory

简单工厂模式，首先，我们要明确我们的产品。比如，我之前在互联网金融公司做架构，当时我们每天要发标，也就是发布用户可以购买的信托产品。

然后信托产品也是分种类的，我们当时做的都是集合信托，但是资金投向方式不同，需要展示给用户的信托信息也不同，如：基础设施类信托、房地产信托、工商企业类信托、证券投资类信托、银信合作类信托、消费金融类信托等。

简单工厂模式，所有创建产品的逻辑都在一个简单工厂类里，如果有一个产品的创建逻辑发生变化，则修改可能会影响其他产品，违背**开闭原则**、**单一职责原则**。

# 2. 工厂方法模式 Factory Method

工厂方法模式（Factory Method Pattern）是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。

属于 GOF 23 种设计模式之一，**创建型设计模式**。

解决问题：产品链增加，造成的工厂类职责过多。简单工厂每次增加产品，都会违背开闭原则，去进行创建产品方法的修改。

将创建一个产品的逻辑放到一个类里面，符合**单一职责原则**。每次增加一个产品，就增加一个工厂类，不用每次都去修改简单工厂的创建产品方法。

使用的时候，将选择权交给用户。遵循**单一职责原则**，只有一个可能引起类变化修改的原因。

把简单工厂的工厂类职责拆离，不同的工厂生产不同的产品。每一种产品都有相应的子工厂创建，发生修改变更只会影响自己，不会影响其他产品。方便代码的扩展维护，扩展时不用修改原来的代码，遵循开闭原则。

适用场景：

1. 创建对象需要大量重复的代码。
2. 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。
3. 一个类通过其子类来指定创建哪个对象。

优点：

1. 用户只需关心所需产品对应的工厂，无须关心创建细节。
2. 加入新产品符合开闭原则，提高了系统的可扩展性。

缺点：

1. 类的个数容易过多，增加了代码结构的复杂度。
2. 增加了系统的抽象性和理解难度。

# 3. 抽象工厂模式 Abstract Factory Pattern

抽象工厂模式（Abstract Factory Pattern）是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。

属于创建型设计模式。

工厂可能不存在，设计好了他的创建模板，工厂可能是后来才生成的。逻辑抽象好，写在最顶层，这样进一步提升了扩展性。

理解抽象工厂模式必须要理解产品族和产品等级结构的概念。

- 一个产品族可以理解为一个品牌，该品牌的产品族包括冰箱、洗衣机、空调等，一个品牌下面有多个产品，构成产品族，一个产品有多个产品等级结构（产品规格）
- 如果一个产品族（品牌）中的每个产品有多个产品等级结构，就适合使用抽象工厂模式

我们的信托标的为了提供更好的流动性和灵活性、以及进行运营活动，增加了活期标、可转让标、体验标，原来的标的都是定期的不可转让标旳。

- 我们可以把标的原来的类型（基础设施类信托、房地产信托、工商企业类信托等）看作产品族，而新的活期标、可转让标、活动标看作产品等级结构
- 活期标类比余额宝；可转让标类比可转让的银行定期存款；体验比类比余额宝体验金；定期标的类比银行定期