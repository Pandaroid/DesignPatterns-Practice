# 解释器模式

解释器模式更多的是用在框架设计层面

- 平常用得比较少
- 特定场景下用得多

解释器模式（Interpreter Pattern）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的例子。

- 特征：为了解释一种语言，而为语言创建的解释器。
- 属于行为型模式

比如 Java 的解释器解释为机器码执行。

- 将固定的文法、语法进行解释，作用类似编译器
- 解释器是一个简单的语法分析器，可以识别句子的语意，分离句子的终结符号和非终结符号，提取出我们需要的信息
  - 针对不同的信息，进行相应的处理

核心思想：识别文法，构建解释

生活中的解释器模式：

- 音乐简谱
- 摩斯密码

对固定文法，构建解释句子的解释器

- JSP 中 EL 表达式
  - 输出是通过运行时解释，将表达式的结果计算出来
- Spring AOP 中的切面表达式
  - 也是通过表达式的解释器来得到最终的结果

解释器模式的适用场景：

- 一些重复出现的问题可以用一种简单的语言来进行表达
- 一个简单语法需要解释的场景

我们以前 SaaS 平台的动态表单的自动计算字段和报表的表达式，都是使用了解释器模式。

- 用户通过专门的编辑器，编辑公式，不用通用的 IKExpression 和 Spring 的 Expression 的原因：
  - 涉及到关联动态表单和字段，以及一些特殊的 Function ，比如时间类型字段有需要排除节假日（计算考勤）、引用其他动态表单字段、子表聚集操作
  - 可以进行优化，更灵活，比如某个字段的值在运行时计算解析时，需要查询的字段有多次使用的，就可以做缓存优化
- 编辑时保存公式的原始字符串，需要进行验证
  - 验证时，使用 Builder 进行建造 Interpreter Expression 的解析建造，能 Build 成功即可
  - 此时要看运行结果，需要选择具体的有权限的动态表单数据实例
  - 具体执行时，对使用的数据进行查询和缓存，解析出结果

解释器模式在框架源码中的使用：

- JDK 中的使用，JDK 源码 java.util.regex.Pattern.java ：正则表达式的解析器
- Spring 的 Expression 中的使用，org.springframework.expression.ExpressionParser
  - org.springframework.expression.spel.standard.SpelExpressionParser

解释器模式优点：

- 扩展性强：在解释器模式中，由于语法是由很多类表示的，当语法规则更改时，只需修改相应的非终结符表达式即可；若扩展语法时，只需添加相应非终结符类即可
- 增加了新的解释表达式的方式
- 易于实现文法：解释器模式对应的文法应当是比较简单且易于实现的，过于复杂的语法并不适合使用解释器模式

解释器模式缺点：

- 语法规则较复杂时，会引起类膨胀、类爆炸
- 执行效率比较低
  - 面向过程执行效率会高点，但是扩展性、可读性、可维护性等就低了
  - 类增加了，结构复杂了，效率会低点
  - 解释器模式中通常会用到 Stack 和递归，递归会降低执行效率，复杂的话，层级会比较深，解析效率会下降